/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   trie                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldutriez <ldutriez@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/08/16 10:53:07 by ldutriez          #+#    #+#             */
/*   Updated: 2022/08/16 20:25:35 by ldutriez         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include <exception>

// TODO Might remove throws and use bool instead

/**
** @brief Implementation of Trie structure in c++
**/
class trie
{
	public:

		trie(): _root(new node) {}
		~trie() {
			delete _root;
		}

		void insert(const std::string &word)
		{
			node *current = _root;
			for (auto c : word) {
				if (isalpha(c) == false)
					throw not_alphabetical_value("insert", word);
				c = toupper(c);
				if (current->next[c - 'A'] == nullptr)
					current->next[c - 'A'] = new node;
				current = current->next[c - 'A'];
			}
			current->is_word = true;
			std::cout << word << " has been inserted in the trie" << std::endl;
		}

		bool search(const std::string &word) {
			node *current = _root;
			for (auto c : word) {
				if (isalpha(c) == false)
					throw not_alphabetical_value("search", word);
				c = toupper(c);
				if (current->next[c - 'A'] == nullptr)
				{
					std::cout << word << " is not in the trie" << std::endl;
					return false;
				}
				current = current->next[c - 'A'];
			}
			std::cout << std::boolalpha << word << " is in trie : " << current->is_word << std::endl;
			return current->is_word;
		}

		/**
		 * @brief Print every word in alphabetical order
		 * starting from the given prefix. If none given, print all words.
		 */
		void print(std::string prefix = "")
		{
			if (prefix == "")
				_print(_root, "");
			else
			{
				node *current = _root;
				for (char &c : prefix) {
					if (isalpha(c) == false)
						throw not_alphabetical_value("print", prefix);
					c = toupper(c);
					if (current->next[c - 'A'] == nullptr)
						return ;
					current = current->next[c - 'A'];
				}
				_print(current, prefix);
			}
		}

	private:

		class not_alphabetical_value : public std::exception {
			public:
				not_alphabetical_value(const std::string &method, const std::string &value) : msg("trie::" + method + " " + value + " not alphabetical") {}
				~not_alphabetical_value() {}

				const char *what() const throw() {
					return msg.c_str();
				}
			
			private:
				const std::string msg;
		};

		class node 
		{
			public:
				node(): is_word(false) {
					for (int i = 0; i < 26; i++)
						next[i] = nullptr;
				}
				~node() {
					for (int i = 0; i < 26; i++)
						delete next[i];
				}
				bool is_word;
				node *next[26];
		};

		/**
		 * @brief Print every word starting from the given node
		 * 
		 * @param current 
		 */
		void _print(node *current, std::string prefix)
		{
			if (current == nullptr)
				return ;
			if (current->is_word)
				std::cout << prefix << std::endl;
			for (int i = 0; i < 26; i++)
				if (current->next[i] != nullptr)
				{
					prefix += char(i + 'A');
					_print(current->next[i], prefix);
					prefix.pop_back();
				}
		}
		
		node *_root;
};