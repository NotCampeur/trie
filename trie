/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   trie                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldutriez <ldutriez@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/08/16 10:53:07 by ldutriez          #+#    #+#             */
/*   Updated: 2022/08/24 22:10:28 by ldutriez         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include <exception>

//TODO: Add iterator to go through each words.
//TODO: Add constructor parameter to give a "Base" to work on.

/**
** @brief Implementation of Trie structure in c++
**/
class trie
{
	public:

		trie(): _root(new node) {}
		trie(const trie &to_copy): _root(new node) {
			*this = to_copy;
		}
		~trie() {
			delete _root;
		}

		trie & operator=(const trie & to_assign)
		{
			if (this != &to_assign)
				*_root = *to_assign._root;
			return *this;
		}

		bool insert(const std::string &word)
		{
			node *current = _root;
			for (auto c : word) {
				if (isalpha(c) == false)
					return false;
				c = toupper(c);
				if (current->next[c - 'A'] == nullptr)
					current->next[c - 'A'] = new node;
				current = current->next[c - 'A'];
			}
			current->is_word = true;
			return true;
		}

		/**
		 * @brief Search for a given word and erase it from the trie.
		 * Delete every letters that are not part of a common prefix.
		 *
		 * @param to_erase The word to erase from the trie.
		 * @return Return true if the word is not in the trie after this function.
		 * False in case of bad entry.
		 */
		bool erase(const std::string & to_erase)
		{
			return _erase(_root, to_erase);
		}

		bool search(const std::string &word) {
			node *current = _root;
			for (auto c : word)
			{
				if (isalpha(c) == false)
					return false;
				c = toupper(c);
				if (current->next[c - 'A'] == nullptr)
					return false;
				current = current->next[c - 'A'];
			}
			return current->is_word;
		}

		/**
		 * @brief Print every word in alphabetical order
		 * starting from the given prefix. If none given, print all words.
		 * Only a debug function to print in cout.
		 */
		bool print(std::string prefix = "")
		{
			if (prefix == "")
				_print(_root, "");
			else
			{
				node *current = _root;
				for (char &c : prefix) {
					if (isalpha(c) == false)
						return false;
					c = toupper(c);
					if (current->next[c - 'A'] == nullptr)
						return false;
					current = current->next[c - 'A'];
				}
				_print(current, prefix); //TODO Need to return _print().
			}
			return true;
		}

	private:

		class node 
		{
			public:
				node(): is_word(false) {
					for (int i = 0; i < 26; i++)
						next[i] = nullptr;
				}
				node(const node & to_copy): is_word(to_copy.is_word)
				{
					*this = to_copy;
				}
				~node() {
					for (int i = 0; i < 26; i++)
						delete next[i];
				}
				node & operator=(const node & to_assign)
				{
					if (this != &to_assign)
					{
						is_word = to_assign.is_word;
						for (int i = 0; i < 26; i++)
							if (to_assign.next[i] != nullptr)
							{
								next[i] = new node;
								*next[i] = *to_assign.next[i];
							}
					}
					return *this;
				}
				bool is_word;
				node *next[26];
		};

		/**
		 * @brief Tell if a node is a word or part of one.
		 * 
		 * @param current The node to check.
		 * @return true if current is a word or a prefix
		 */
		bool _is_prefix(node *current)
		{
			if (current->is_word == true)
				return true;
			bool is_prefix(false);
			for (int i(0); i < 26; ++i)
				if (current->next[i] != nullptr)
					is_prefix = true;
			return is_prefix;
		}

		bool _erase(node *current, std::string to_erase)
		{
			if (to_erase.empty() == true)
			{
				current->is_word = false;
				return true;
			}
			char next_c = to_erase.front();
			if (isalpha(next_c) == false)
				return false;
			next_c = toupper(next_c);
			if (current->next[next_c - 'A'] == nullptr)
				return true;
			if (_erase(current->next[next_c - 'A'], to_erase.substr(1)) == false)
				return false;
			if (_is_prefix(current->next[next_c - 'A']) == false)
				delete current->next[next_c - 'A'];
			return true;
		}

		/**
		 * @brief Print every word starting from the given node
		 * Only a debug function to print in cout.
		 * 
		 * @param current 
		 */
		void _print(node *current, std::string prefix)
		{
			if (current == nullptr)
				return ;
			if (current->is_word)
				std::cout << prefix << std::endl;
			for (int i = 0; i < 26; i++)
				if (current->next[i] != nullptr)
				{
					prefix += char(i + 'A');
					_print(current->next[i], prefix);
					prefix.pop_back();
				}
		}
		
		node *_root;
};