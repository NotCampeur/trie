/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   trie                                               :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: ldutriez <ldutriez@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2022/08/16 10:53:07 by ldutriez          #+#    #+#             */
/*   Updated: 2022/08/23 09:35:07 by ldutriez         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#pragma once

#include <iostream>
#include <exception>

/**
** @brief Implementation of Trie structure in c++
**/
class trie
{
	public:

		trie(): _root(new node) {}
		trie(const trie &to_copy): _root(new node) {
			*this = to_copy;
		}
		~trie() {
			delete _root;
		}

		trie & operator=(const trie & to_assign)
		{
			if (this != &to_assign)
				*_root = *to_assign._root;
			return *this;
		}

		bool insert(const std::string &word)
		{
			node *current = _root;
			for (auto c : word) {
				if (isalpha(c) == false)
					return false;
				c = toupper(c);
				if (current->next[c - 'A'] == nullptr)
					current->next[c - 'A'] = new node;
				current = current->next[c - 'A'];
			}
			current->is_word = true;
			return true;
		}

		bool search(const std::string &word) {
			node *current = _root;
			for (auto c : word)
			{
				if (isalpha(c) == false)
					return false;
				c = toupper(c);
				if (current->next[c - 'A'] == nullptr)
					return false;
				current = current->next[c - 'A'];
			}
			return current->is_word;
		}

		/**
		 * @brief Print every word in alphabetical order
		 * starting from the given prefix. If none given, print all words.
		 * Only a debug function to print in cout.
		 */
		bool print(std::string prefix = "")
		{
			if (prefix == "")
				_print(_root, "");
			else
			{
				node *current = _root;
				for (char &c : prefix) {
					if (isalpha(c) == false)
						return false;
					c = toupper(c);
					if (current->next[c - 'A'] == nullptr)
						return false;
					current = current->next[c - 'A'];
				}
				_print(current, prefix);
			}
			return true;
		}

	private:

		class node 
		{
			public:
				node(): is_word(false) {
					for (int i = 0; i < 26; i++)
						next[i] = nullptr;
				}
				node(const node & to_copy): is_word(to_copy.is_word)
				{
					*this = to_copy;
				}
				~node() {
					for (int i = 0; i < 26; i++)
						delete next[i];
				}
				node & operator=(const node & to_assign)
				{
					if (this != &to_assign)
					{
						is_word = to_assign.is_word;
						for (int i = 0; i < 26; i++)
							if (to_assign.next[i] != nullptr)
							{
								next[i] = new node;
								*next[i] = *to_assign.next[i];
							}
					}
					return *this;
				}
				bool is_word;
				node *next[26];
		};

		/**
		 * @brief Print every word starting from the given node
		 * Only a debug function to print in cout.
		 * 
		 * @param current 
		 */
		void _print(node *current, std::string prefix)
		{
			if (current == nullptr)
				return ;
			if (current->is_word)
				std::cout << prefix << std::endl;
			for (int i = 0; i < 26; i++)
				if (current->next[i] != nullptr)
				{
					prefix += char(i + 'A');
					_print(current->next[i], prefix);
					prefix.pop_back();
				}
		}
		
		node *_root;
};